function solution(arr, m) {
  let answer = [];
  let tmp = Array.from({ length: m }, () => 0);
  let ch = Array.from({ length: arr.length }, () => 0);

  const DFS = (L) => {
    if (L === m) {
      answer.push([...tmp]);
    } else {
      for (let i = 0; i < arr.length; i++) {
        // 해당 자리의 숫자가 사용되었는지 판별
        // 사용이 안되었으면 tmp에 자리의 숫자를 넣어주고
        // 다음 깊이로 재귀함수 호출
        // 그대로 쭉 실행해가면서 tmp를 채우다가 깊이가 m이 되었을 때, tmp의 값을 answer에 푸시
        // 재귀를 빠져나와서 다시 해당 값을 0으로 초기화 하고 for문의 다음 i 값으로 가서 다시 재귀함수 시작
        // L이 0 일 때, for문을 돈다
        // i = 0 일 때
        // 1. ch[0]의 값 확인 (0으로 모두 초기화한 상태이기 때문에 ch[0]은 0)
        // 2. 0이기 때문에, tmp[L]인 tmp[0]에 arr[i] (i는 현재 0)인 3을 넣어준다. tmp는 이 때 [3,0]
        // 3. 동시에 ch[0]을 1로 바꿔서 ch[0]은 사용했다는 표시를 해준다. ch는 [1,0,0]
        // 4. L에 1을 더해 재귀함수를 호출
        // L이 1인 상태에서 for문 시작
        // 같은 로직으로 1번으로 가는데 ch[0]의 값이 1이기 때문에 아무 로직없이 넘어간다.
        // i가 1이 되고, ch[1]의 값이 0이기 때문에 tmp[1]에 arr[1]을 넣어준다. tmp는 [3,6]
        // 다시 ch[1]의 값을 1로 바꾸고 DFS(2) 호출
        // DFS(2) 에서는 answer에 [3,6]을 push (현재 tmp의 값)
        // push 후 DFS(2) 함수가 콜 스택에서 제거되고, DFS(1) 함수의 ch[1]의 값으로 0으로 바꾼다. ch 는 [1,0,0]
        // 다시 i가 2가 되고, ch[2]는 0이기 때문에 tmp[1]의 값을 arr[2]인 9로 바꾼다. tmp는 [3,9]
        // ch[2]를 1로 바꾸고 DFS(2)를 호출 후, answer에 tmp를 push. 현재 answer는 [[3,6], [3,9]]
        // DFS(2) 종료 후, ch[2]를 다시 0으로 바꾸고 for문 종료 및 DFS(1)의 i가 1인 for문으로 돌아감
        if (ch[i] === 0) {
          tmp[L] = arr[i];
          ch[i] = 1;
          DFS(L + 1);
          ch[i] = 0;
        }
      }
    }
  };

  DFS(0);

  answer.push(answer.length);

  return answer;
}

console.log(solution([3, 6, 9], 2));

/**
 * 순열 구하기
 *
 * 10 이하의 N개의 자연수가 주어지면 이 중 M개를 뽑아 일렬로 나열하는 방법을 모두 출력합니다.
 * ▣ 입력설명
 * 첫 번째 줄에 자연수 N(3<=N<=10)과 M(2<=M<=N) 이 주어집니다. 두 번째 줄에 N개의 자연수가 오름차순으로 주어집니다.
 *
 * ▣ 출력설명
 * 첫 번째 줄에 결과를 출력합니다. 맨 마지막 총 경우의 수를 출력합니다. 출력순서는 사전순으로 오름차순으로 출력합니다.
 *
 * ▣ 입력예제 1
 * 3 2
 * 3 6 9
 *
 * ▣ 출력예제 1
 * 3 6
 * 3 9
 * 6 3
 * 6 9
 * 9 3
 * 9 6
 * 6
 */
